package rr.tool;
import rr.event.ArrayAccessEvent;
import rr.event.FieldAccessEvent;
import rr.state.AbstractArrayState;
import rr.state.ShadowThread;
import rr.state.ShadowVar;
import acme.util.Util;
import rr.event.AcquireEvent;
import rr.event.ArrayAccessEvent;
import rr.event.FieldAccessEvent;
import rr.event.JoinEvent;
import rr.event.MethodEvent;
import rr.event.NotifyEvent;
import rr.event.ReleaseEvent;
import rr.event.SleepEvent;
import rr.event.StartEvent;
import rr.event.VolatileAccessEvent;
import rr.event.WaitEvent;
import rr.meta.MetaDataInfoMaps;
import rr.meta.ArrayAccessInfo;
import rr.meta.FieldAccessInfo;
import rr.meta.MethodInfo;
import rr.state.AbstractArrayState;
import rr.state.ShadowLock;
import rr.state.ShadowThread;
import rr.state.ShadowVar;
import rr.state.ShadowVolatile;
import rr.state.update.AbstractFieldUpdater;
import acme.util.AtomicFlag;
import acme.util.Util;
import acme.util.option.CommandLine;
import acme.util.option.CommandLineOption;
import acme.util.Assert;
import acme.util.Yikes;
public class RRValueEventGenerator extends RR {
public static char writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, char oldValue, char newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getcharValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static char volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, char oldValue, char newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getcharValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static char readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, char oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); char newValue = ae.newValue.getcharValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static char volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, char oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); char newValue = ae.newValue.getcharValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static char arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, char oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); char newValue = aae.newValue.getcharValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static char arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, char oldValue, char newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getcharValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, char oldValue, char newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, char oldValue, char newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, char oldValue, char newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static short writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, short oldValue, short newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getshortValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static short volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, short oldValue, short newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getshortValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static short readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, short oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); short newValue = ae.newValue.getshortValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static short volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, short oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); short newValue = ae.newValue.getshortValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static short arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, short oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); short newValue = aae.newValue.getshortValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static short arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, short oldValue, short newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getshortValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, short oldValue, short newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, short oldValue, short newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, short oldValue, short newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static int writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, int oldValue, int newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getintValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static int volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, int oldValue, int newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getintValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static int readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, int oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); int newValue = ae.newValue.getintValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static int volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, int oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); int newValue = ae.newValue.getintValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static int arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, int oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); int newValue = aae.newValue.getintValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static int arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, int oldValue, int newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getintValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, int oldValue, int newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, int oldValue, int newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, int oldValue, int newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static long writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, long oldValue, long newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getlongValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static long volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, long oldValue, long newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getlongValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static long readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, long oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); long newValue = ae.newValue.getlongValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static long volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, long oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); long newValue = ae.newValue.getlongValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static long arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, long oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); long newValue = aae.newValue.getlongValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static long arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, long oldValue, long newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getlongValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, long oldValue, long newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, long oldValue, long newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, long oldValue, long newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static float writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, float oldValue, float newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getfloatValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static float volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, float oldValue, float newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getfloatValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static float readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, float oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); float newValue = ae.newValue.getfloatValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static float volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, float oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); float newValue = ae.newValue.getfloatValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static float arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, float oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); float newValue = aae.newValue.getfloatValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static float arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, float oldValue, float newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getfloatValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, float oldValue, float newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, float oldValue, float newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, float oldValue, float newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static double writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, double oldValue, double newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getdoubleValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static double volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, double oldValue, double newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getdoubleValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static double readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, double oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); double newValue = ae.newValue.getdoubleValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static double volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, double oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); double newValue = ae.newValue.getdoubleValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static double arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, double oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); double newValue = aae.newValue.getdoubleValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static double arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, double oldValue, double newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getdoubleValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, double oldValue, double newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, double oldValue, double newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, double oldValue, double newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static boolean writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean oldValue, boolean newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getbooleanValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static boolean volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean oldValue, boolean newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getbooleanValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static boolean readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); boolean newValue = ae.newValue.getbooleanValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static boolean volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); boolean newValue = ae.newValue.getbooleanValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static boolean arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, boolean oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); boolean newValue = aae.newValue.getbooleanValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static boolean arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, boolean oldValue, boolean newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getbooleanValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, boolean oldValue, boolean newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, boolean oldValue, boolean newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, boolean oldValue, boolean newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static byte writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, byte oldValue, byte newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getbyteValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static byte volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, byte oldValue, byte newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getbyteValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static byte readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, byte oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); byte newValue = ae.newValue.getbyteValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static byte volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, byte oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); byte newValue = ae.newValue.getbyteValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static byte arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, byte oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); byte newValue = aae.newValue.getbyteValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static byte arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, byte oldValue, byte newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getbyteValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, byte oldValue, byte newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, byte oldValue, byte newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, byte oldValue, byte newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
public static Object writeAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, Object oldValue, Object newValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, true, oldValue, newValue); firstAccess.access(ae); ae.setInfo(null); newValue = ae.newValue.getObjectValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static Object volatileWriteAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, Object oldValue, Object newValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, true, oldValue, newValue); getTool().volatileAccess(ae); ae.setInfo(null); newValue = ae.newValue.getObjectValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static Object readAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, Object oldValue) { FieldAccessEvent ae = prepAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); firstAccess.access(ae); ae.setInfo(null); Object newValue = ae.newValue.getObjectValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } public static Object volatileReadAccess(Object target, ShadowVar gs, int fadId, ShadowThread td, Object oldValue) { try { VolatileAccessEvent ae = prepVolatileAccessEvent(target, gs, fadId, td, false, oldValue, oldValue); getTool().volatileAccess(ae); ae.setInfo(null); Object newValue = ae.newValue.getObjectValue(); ae.oldValue.clear(); ae.newValue.clear(); return newValue; } catch (Throwable e) { Assert.panic(e); return oldValue; } } public static Object arrayRead(Object array, int index, int arrayAccessId, ShadowThread td, Object oldValue) { if (!RREventGenerator.matches(index)) return oldValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, false, oldValue, oldValue); firstAccess.access(aae); Object newValue = aae.newValue.getObjectValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } public static Object arrayWrite(Object array, int index, int arrayAccessId, ShadowThread td, Object oldValue, Object newValue) { if (!RREventGenerator.matches(index)) return newValue; final AbstractArrayState as = RREventGenerator.arrayShadow(array, index, arrayAccessId, td); final ArrayAccessEvent aae = prepArrayAccessEvent(array, index, arrayAccessId, td, as, true, oldValue, newValue); firstAccess.access(aae); newValue = aae.newValue.getObjectValue(); aae.oldValue.clear(); aae.newValue.clear(); return newValue; } protected static FieldAccessEvent prepAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, Object oldValue, Object newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); FieldAccessEvent fae = td.getFieldAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static VolatileAccessEvent prepVolatileAccessEvent(Object target, ShadowVar gs, int fadId, ShadowThread td, boolean isWrite, Object oldValue, Object newValue) { FieldAccessInfo fad = MetaDataInfoMaps.getFieldAccesses().get(fadId); AbstractFieldUpdater updater = fad.getField().getUpdater(); VolatileAccessEvent fae = td.getVolatileAccessEvent(); fae.setTarget(target); fae.setInfo(fad); fae.setUpdater(updater); fae.setWrite(isWrite); fae.oldValue.setValue(oldValue); fae.newValue.setValue(newValue); fae.setShadowVolatile(ShadowVolatile.get(target, fad.getField())); if (gs == null) { fae.putOriginalShadow(null); gs = getTool().makeShadowVar(fae); if (!fae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = updater.getState(target); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } fae.putOriginalShadow(gs); return fae; } protected static ArrayAccessEvent prepArrayAccessEvent(Object array, int index, int arrayAccessId, ShadowThread td, AbstractArrayState as, boolean isWrite, Object oldValue, Object newValue) { final ArrayAccessInfo aad = MetaDataInfoMaps.getArrayAccesses().get(arrayAccessId); ArrayAccessEvent aae = td.getArrayAccessEvent(); aae.setIndex(index); aae.setWrite(isWrite); aae.setTarget(array); aae.setInfo(aad); aae.setArrayState(as); aae.oldValue.setValue(oldValue); aae.newValue.setValue(newValue); ShadowVar gs = as.getState(index); if (gs == null) { aae.putOriginalShadow(null); gs = getTool().makeShadowVar(aae); if (!aae.putShadow(gs)) { Yikes.yikes("Concurrent guard state init..."); gs = as.getState(index); Assert.assertTrue(gs != null, "concurrent updates to new var state not resolved properly"); } } aae.putOriginalShadow(gs); return aae; }
}
